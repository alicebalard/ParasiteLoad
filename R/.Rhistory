fit_neg_bin(Joelle_data$Aspiculuris.Syphacia)
fit_neg_bin(Joelle_data$Trichuris)
fit_neg_bin(Joelle_data$Taenia)
fit_neg_bin(Joelle_data$Mastophorus)
MeanLoad <- function(intercept, growth, alpha, HI){
(intercept + growth*HI)*(1 - alpha*2*HI*(1 - HI))
}
MeanLoad <- function(intercept, growth, alpha, HI){
(intercept + growth*HI)*(1 - alpha*2*HI*(1 - HI))
}
MeanLoad(73.95,(73.95 - 33.49), 1.39, 0.5)
59.72 - MeanLoad(73.95,(73.95 - 33.49), 1.39, 0.5)
Joelle_data <- read.csv("../../../EvolutionFinalData.csv")
Joelle_data <- read.csv("../../EvolutionFinalData.csv")
library(exactci)
library(MASS)
graphics.off()
par("mar")
par(mar=c(1,1,1,1))
devtools::check()
devtools::check()
devtools::check()
devtool::install_github("alicebalard/Parasite_Load")
library(devtools)
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
G1 <- glm.hybrid::glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
simpara <- c(k = 2, alpha = 1.92,
"male:old.inter" = 14,
"male:young.inter" = 12,
"male:baby.inter" = 10,
"female:old.inter" = 20,
"female:young.inter" = 18,
"female:baby.inter" = 11,
"male:old.growth" = 2,
"male:young.growth" = 1,
"male:baby.growth" = -4,
"female:old.growth" = 2,
"female:young.growth" = 0,
"female:baby.growth" = -1)
SimulatedData <- function(param, n){
gdata <- data.frame(group1 = rep(c("male", "female"), each=n/2),
group2 = sample(c("old", "young", "baby"),
n, replace=TRUE))
gdata$HI<- round(runif(n), 2)
xloads <- by(gdata, gdata$group1:gdata$group2, function (x) {
pattern <- paste0("^", unique(x$group1), ":", unique(x$group2))
this.param <- param[grepl(pattern, names(param))]
loads <- rnbinom(n = nrow(x), size = param["k"],
mu = glm.hybrid:::MeanLoad(intercept=this.param[grepl("\\.inter",
names(this.param))],
growth=this.param[grepl("\\.growth",
names(this.param))],
alpha=param["alpha"],
HI=x$HI))
cbind(x, loads)
})
as.data.frame(do.call("rbind", xloads))
}
set.seed(5)
simdata <- SimulatedData(simpara, 1000)
G1 <- glm.hybrid::glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
G1
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
G1 <- glm.hybrid::glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
## Plot results for one group
HI = seq(0,1,0.001)
df <- data.frame(HI = HI,
ML = MeanLoad(G1$opt.param["female.inter"], G1$opt.param["female.growth"],
G1$opt.param["alpha"], HI))
library(ggplot2)
ggplot2::ggplot(df, aes(x = HI, y = ML)) +
geom_point() +
theme_classic()
devtools::check()
devtools::check()
devtools::check()
simpara <- c(k = 2, alpha = 1.92,
"male:old.inter" = 14,
"male:young.inter" = 12,
"male:baby.inter" = 10,
"female:old.inter" = 20,
"female:young.inter" = 18,
"female:baby.inter" = 11,
"male:old.growth" = 2,
"male:young.growth" = 1,
"male:baby.growth" = -4,
"female:old.growth" = 2,
"female:young.growth" = 0,
"female:baby.growth" = -1)
SimulatedData <- function(param, n){
gdata <- data.frame(group1 = rep(c("male", "female"), each=n/2),
group2 = sample(c("old", "young", "baby"),
n, replace=TRUE))
gdata$HI<- round(runif(n), 2)
xloads <- by(gdata, gdata$group1:gdata$group2, function (x) {
pattern <- paste0("^", unique(x$group1), ":", unique(x$group2))
this.param <- param[grepl(pattern, names(param))]
loads <- rnbinom(n = nrow(x), size = param["k"],
mu = glm.hybrid:::MeanLoad(intercept=this.param[grepl("\\.inter",
names(this.param))],
growth=this.param[grepl("\\.growth",
names(this.param))],
alpha=param["alpha"],
HI=x$HI))
cbind(x, loads)
})
as.data.frame(do.call("rbind", xloads))
}
set.seed(5)
simdata <- SimulatedData(simpara, 1000)
View(simdata)
## INPUT
## alice.ml.nb(bristles ~ latitude + sex + strain, data = drosophila)
## OUTPUT
## alpha                          -   estimate, lower, upper
## factor1..N * intercept         -   estimate, lower, upper
## factor1..N * growth            -   estimate, lower, upper
## Z                              -   estimate, lower, upper
## factor1..N * initialAgg        -   estimate, lower, upper
## factor1..N * growthAgg         -   estimate, lower, upper
##                                    ML estimate
#########################
## MeanLoad model: How does the mean load vary depending on the parameters?
MeanLoad <- function(intercept, growth, alpha, HI){
(intercept + growth*HI)*(1 - alpha*2*HI*(1 - HI))
}
## Aggregation model: How does the aggregation vary depending on the parameters?
Aggregation <- function(initialAgg, growthAgg, Z, HI){
(initialAgg + growthAgg*HI)*(1 - Z*2*HI*(1 - HI))
}
## TO DO : alpha.along should now be renamed "gradient" or "along", as alpha and Z vary along it
## The likelihood function over a set of inds
LogLik <- function(data, param, group.name, response, alpha.along, whichsign = 1){
## split the name into two
gname <- sort(group.name)
split.L<- by(data, data[, gname], function(x)  {
## by makes sure we get all levels: get the name of the parameter
## from the values within the by "loop"
param.pattern <- unique(interaction(x[, gname], sep=":"))
## construct a regex with it
par.regex <- paste0("^Z$|alpha|^", param.pattern)
## select from our ugly paramter collection
sub.param <- param[grepl(par.regex, names(param))]
l.lik <- stats::dnbinom(x[, response],
mu=abs(MeanLoad(alpha=sub.param[names(sub.param) %in% "alpha"],
intercept=sub.param[grepl("inter",
names(sub.param))],
growth=sub.param[grepl("growth", names(sub.param))],
HI=x[, alpha.along])),
size = 1/abs(Aggregation(Z = sub.param[names(sub.param) %in% "Z"],
initialAgg = sub.param[grepl("initialAgg",
names(sub.param))],
growthAgg = sub.param[grepl("growthAgg", names(sub.param))],
HI = x[, alpha.along])),
log = TRUE)
l.lik
})
all.l.lik <- unlist(split.L)
if(length(all.l.lik)!=nrow(data)){
stop("Not all likelihoods considered, group/parameter matching problem")
} else{
sum(all.l.lik) * whichsign
}
}
# The likelihood analysis
hybrid.maxim <- function (param, data, group.name, response = response,
alpha.along, hessian=FALSE, control = list(fnscale=-1),
whichsign = 1){
stats::optim(par = param,
fn = LogLik, ## function to be maximized
control = control, ## maximise by default
method = "L-BFGS-B",
data = data,
group.name = group.name,
response = response,
alpha.along = alpha.along,
whichsign =  whichsign,
hessian = hessian)
}
##Approximation of the CI by hessian matrix
# Wald test (cf "Max Lik estimation and Inference book) p46:
ML_bounds_Wald <- function(param, data, group.name,
response, alpha.along){
# use start values inferred from glm.nb:
fit.include.hessian <- hybrid.maxim(param = param, data = data,
group.name = group.name,
response = response,
alpha.along = alpha.along,
hessian = TRUE, whichsign = -1,
control = list())
MLE <- fit.include.hessian$par
ObsInfo <- fit.include.hessian$hessian # observed Fisher information matrix
Vhat <- solve(ObsInfo) # inverse of observed Fisher information matrix
Std.errors <- sqrt(diag(Vhat))
# obtain the MLEs, estimated std errors, and approx Wald 95% CIs
Wald.table <- cbind(MLE,
Std.errors,
LowerBounds = MLE - stats::qnorm(0.975)*Std.errors,
UpperBounds = MLE + stats::qnorm(0.975)*Std.errors)
round(Wald.table, 4)
}
#  Likelihood Ratio Test NB think about the dDF definition in this case...
anova.hybrid <- function(m1, m2){
## Test if the difference between 2 likelihood is significant
dLL = abs(m1$twologlik/2 - m2$twologlik/2)
dDF = length(m1$opt.param) - length(m2$opt.param)
p = 1 - stats::pchisq(2*dLL, df = dDF) # G-test
print(list(c(dLL = dLL, dDF = dDF, p = p)))
}
glm.hybrid <- function(formula, data,
alpha.along,
alpha.start = 0.1,
start.mod = MASS::glm.nb,
start.values = NA){
## create the formula in the environment of our function
formula <- formula(substitute(formula))
response <- all.vars(formula)[1]
if(!class(start.mod)%in%"function"){
stop("supply a function to estimate starting parameters, even if you supply parameters verbatim (via start.values) use this for structure")
}
nb <- start.mod(formula, data=data)
nb.e  <- effects::allEffects(nb, xlevels=2)
if(length(nb.e) > 1){
stop("glm.hybrid not only currently only implements models with all potential interactions defined")
} else {
nb.e <- nb.e[[1]]
var <- nb.e[["variables"]]
is.factor.var <- sapply(var, function (x) x[["is.factor"]])
factor.var <- sort(names(is.factor.var[is.factor.var]))
alpha.var <- names(is.factor.var[!is.factor.var])
if (length(alpha.var) != 1 ||
!all(alpha.var %in% alpha.along) ||
max(data[, alpha.var]) > 1 ||
min(data[, alpha.var]) < 0){
stop("glm.hybrid is currently only implemented for one continuous variable scaled between 0 and 1, along which a non-linar effect (of intensity alpha) is tested")
} else {
original.inverse <- nb.e$transformation$inverse
nb.t <- as.data.frame(nb.e, transform = original.inverse)
start.param <- nb.t[, "fit"]
start.param
#
# ## if > 1 group, then nb.t[ , factor.var] is a data.frame
# if (length(factor.var) == 1){
#   names(start.param) <- nb.t[, factor.var]
# } else {
#   names(start.param) <- apply(nb.t[, factor.var], 1, paste, collapse=":")
# }
# names(start.param) <- paste0(names(start.param),
#                              rep(c(".inter", ".growth",
#                                    ".initialAgg", ".growthAgg"),
#                                  times = length(start.param)/4))
# ## we could reduce this by simply using ever even number parameter as intercept uneven as growth
# ## same in the ML loglik function
# start.param[grepl("growth$", names(start.param))] <-
#   start.param[grepl("growth$", names(start.param))] -
#   start.param[grepl("inter$", names(start.param))]
# param <- c(k=nb$theta, alpha=alpha.start, start.param)
# param[names(start.values)] <- start.values
#
# opt <- hybrid.maxim(param = param, data = data,
#                     group.name = factor.var,
#                     response = response,
#                     alpha.along = alpha.along)
# ## add proxy of 95%CI
# # bounds <- ML_bounds_Wald(param = param, data = data,
# #                         group.name = factor.var,
# #                        response = response,
# #                       alpha.along = alpha.along)
# out <- list(twologlik = opt$value*2,
#             start.mod = substitute(start.mod),
#             start.param = param[names(opt$par)],
#             override.start.values = start.values[names(opt$par)],
#             opt.param = opt$par,
#             #           opt.lower = bounds[,"LowerBounds"],
#             #           opt.upper = bounds[,"UpperBounds"],
#             df.residual = nb$df.residual-1,
#             converged = as.logical(opt$convergence))
# class(out) <- append(class(out),"hybrid.glm")
# return(out)
}
}
}
simpara <- c(k = 2, alpha = 1.92,
"male:old.inter" = 14,
"male:young.inter" = 12,
"male:baby.inter" = 10,
"female:old.inter" = 20,
"female:young.inter" = 18,
"female:baby.inter" = 11,
"male:old.growth" = 2,
"male:young.growth" = 1,
"male:baby.growth" = -4,
"female:old.growth" = 2,
"female:young.growth" = 0,
"female:baby.growth" = -1)
SimulatedData <- function(param, n){
gdata <- data.frame(group1 = rep(c("male", "female"), each=n/2),
group2 = sample(c("old", "young", "baby"),
n, replace=TRUE))
gdata$HI<- round(runif(n), 2)
xloads <- by(gdata, gdata$group1:gdata$group2, function (x) {
pattern <- paste0("^", unique(x$group1), ":", unique(x$group2))
this.param <- param[grepl(pattern, names(param))]
loads <- rnbinom(n = nrow(x), size = param["k"],
mu = glm.hybrid:::MeanLoad(intercept=this.param[grepl("\\.inter",
names(this.param))],
growth=this.param[grepl("\\.growth",
names(this.param))],
alpha=param["alpha"],
HI=x$HI))
cbind(x, loads)
})
as.data.frame(do.call("rbind", xloads))
}
set.seed(5)
simdata <- SimulatedData(simpara, 1000)
G1 <- glm.hybrid::glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
G1 <- glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
G1 <- glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
G1
G1 <- glm.hybrid::glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
G1
G1 <- glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
G1
G1 <- glm.hybrid::glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
G1
G1 <- glm.hybrid::glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
G1
source('~/Desktop/git_projects/Parasite_Load/R/UserInput.R')
G1 <- glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
G1
source('~/Desktop/git_projects/Parasite_Load/R/UserInput.R')
G1 <- glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
G1
source('~/Desktop/git_projects/Parasite_Load/R/UserInput.R')
G1 <- glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
G1
source('~/Desktop/git_projects/Parasite_Load/R/UserInput.R')
G1 <- glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
G1
source('~/Desktop/git_projects/Parasite_Load/R/UserInput.R')
G1 <- glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
G1
source('~/Desktop/git_projects/Parasite_Load/R/UserInput.R')
G1 <- glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
source('~/Desktop/git_projects/Parasite_Load/R/UserInput.R')
G1 <- glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
G1
source('~/Desktop/git_projects/Parasite_Load/R/UserInput.R')
G1 <- glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
G1
source('~/Desktop/git_projects/Parasite_Load/R/ML_functions.R')
source('~/Desktop/git_projects/Parasite_Load/R/UserInput.R')
G1 <- glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
G1
source('~/Desktop/git_projects/Parasite_Load/R/UserInput.R')
G1 <- glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
G1
Aggregation <- function(initialAgg, growthAgg, Z, HI){
(initialAgg + growthAgg*HI)*(1 + Z*2*HI*(1 - HI))
}
Aggregation(1,0.1,0.1,0.5)
Aggregation(2,0.1,0.1,0.5)
Aggregation(5,0.1,0.1,0.5)
Aggregation(5,0,0.1,0.5)
source('~/Desktop/git_projects/Parasite_Load/R/UserInput.R')
G1 <- glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
G1
source('~/Desktop/git_projects/Parasite_Load/R/UserInput.R')
G1 <- glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
G1
source('~/Desktop/git_projects/Parasite_Load/R/UserInput.R')
G1 <- glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
G1
source('~/Desktop/git_projects/Parasite_Load/R/UserInput.R')
G1 <- glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
G1
source('~/Desktop/git_projects/Parasite_Load/R/UserInput.R')
G1 <- glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
G1
source('~/Desktop/git_projects/Parasite_Load/R/UserInput.R')
G1 <- glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
G1
source('~/Desktop/git_projects/Parasite_Load/R/UserInput.R')
G1 <- glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
G1
source('~/Desktop/git_projects/Parasite_Load/R/UserInput.R')
G1 <- glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
G1
source('~/Desktop/git_projects/Parasite_Load/R/UserInput.R')
G1 <- glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
G1
glm.hybrid(loads ~ HI * group1 * group2, data = simdata, alpha.along = "HI")
source('~/Desktop/git_projects/Parasite_Load/R/UserInput.R')
glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
source('~/Desktop/git_projects/Parasite_Load/R/UserInput.R')
glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
source('~/Desktop/git_projects/Parasite_Load/R/UserInput.R')
glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
source('~/Desktop/git_projects/Parasite_Load/R/ML_functions.R')
glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
source('~/Desktop/git_projects/Parasite_Load/R/ML_functions.R')
glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
source('~/Desktop/git_projects/Parasite_Load/R/ML_functions.R')
glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
source('~/Desktop/git_projects/Parasite_Load/R/ML_functions.R')
glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
G1 <- glm.hybrid::glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
G1
glm.hybrid(loads ~ HI * group1 * group2, data = simdata, alpha.along = "HI")
devtools::check()
source('~/Desktop/git_projects/Parasite_Load/R/UserInput.R')
roxygen2::roxygenise() c
roxygen2::roxygenise()
simdata
Joelledata <- read.csv("/home/alice/Desktop/EvolutionFinalData.csv")
View(Joelledata)
glm.hybrid(Trichuris ~ HI * Sex, data = Joelle_data, alpha.along = "HI")
Joelle_data <- read.csv("/home/alice/Desktop/EvolutionFinalData.csv")
glm.hybrid(Trichuris ~ HI * Sex, data = Joelle_data, alpha.along = "HI")
glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI")
glm.hybrid(Trichuris ~ HI * Sex, data = Joelle_data, alpha.along = "HI")
View(Joelle_data)
is.na(Joelle_data)
Joelle_data[is.na(Joelle_data),]
Joelle_data[!is.na(Joelle_data),]
Joelle_data <- Joelle_data[!is.na(Joelle_data),]
Joelle_data <- read.csv("/home/alice/Desktop/EvolutionFinalData.csv")
Joelle_data <- !is.na(Joelle_data)
Joelle_data <- read.csv("/home/alice/Desktop/EvolutionFinalData.csv")
na.omit(Joelle_data)
Joelle_data <- na.omit(Joelle_data)
glm.hybrid(Trichuris ~ HI * Sex, data = Joelle_data, alpha.along = "HI")
glm.hybrid(Trichuris ~ HI * Sex, data = Joelle_data, alpha.along = "HI")
820.94*2
glm.hybrid(Trichuris ~ HI, data = Joelle_data, alpha.along = "HI")
Joelle_data$All <- "all"
glm.hybrid(Trichuris ~ HI * All, data = Joelle_data, alpha.along = "HI")
Joelle_data$All <- "all"
Joelle_data$All[1] <- "aaaarg"
glm.hybrid(Trichuris ~ HI * All, data = Joelle_data, alpha.along = "HI")
Joelle_data <- read.csv("/home/alice/Desktop/EvolutionFinalData.csv")
Joelle_data <- na.omit(Joelle_data)
Joelle_data$All <- "all"
Joelle_data$All[1] <- "aaaarg"
glm.hybrid(Trichuris ~ HI * All, data = Joelle_data, alpha.along = "HI")
View(Joelle_data)
Joelle_data <- read.csv("/home/alice/Desktop/EvolutionFinalData.csv")
Joelle_data <- na.omit(Joelle_data)
Joelle_data$All <- TRUE
Joelle_data$All[1] <- FALSE
glm.hybrid(Trichuris ~ HI * All, data = Joelle_data, alpha.along = "HI")
is.factor(Joelle_data$Sex)
is.factor(Joelle_data$All)
as.factor(Joelle_data$All)
Joelle_data$All <- as.factor(Joelle_data$All)
glm.hybrid(Trichuris ~ HI * All, data = Joelle_data, alpha.along = "HI")
Joelle_data$All <- TRUE
Joelle_data$All[1] <- FALSE
Joelle_data$All <- as.factor(Joelle_data$All)
glm.hybrid(Trichuris ~ HI * All, data = Joelle_data, alpha.along = "HI")
Joelle_data$All <- "A"
Joelle_data$All[1] <- "B"
Joelle_data$All <- as.factor(Joelle_data$All)
glm.hybrid(Trichuris ~ HI * All, data = Joelle_data, alpha.along = "HI")
glm.hybrid(Trichuris ~ HI * Sex, data = Joelle_data, alpha.along = "HI")
View(Joelledata)
Joelle_data <- read.csv("/home/alice/Desktop/EvolutionFinalData.csv")
Joelle_data <- na.omit(Joelle_data)
Joelle_data$All <- "A"
Joelle_data$All[1] <- "B"
Joelle_data$All <- as.factor(Joelle_data$All)
glm.hybrid(Trichuris ~ HI * All, data = Joelle_data, alpha.along = "HI")
View(Joelle_data)
is.factor(Joelle_data$All)
glm.hybrid(Trichuris ~ HI * All, data = Joelle_data, alpha.along = "HI")
Joelle_data$All[c(1,10)] <- "B"
Joelle_data$All <- as.factor(Joelle_data$All)
is.factor(Joelle_data$All)
glm.hybrid(Trichuris ~ HI * All, data = Joelle_data, alpha.along = "HI")
glm.hybrid(Trichuris ~ HI * All, data = Joelle_data, alpha.along = "HI")
glm.hybrid(Trichuris ~ HI * All, data = Joelle_data, alpha.along = "HI")
source('~/Desktop/git_projects/Parasite_Load/R/ML_functions.R')
glm.hybrid(Trichuris ~ HI * All, data = Joelle_data, alpha.along = "HI")
source('~/Desktop/git_projects/Parasite_Load/R/ML_functions.R')
source('~/Desktop/git_projects/Parasite_Load/R/ML_functions.R')
glm.hybrid(Trichuris ~ HI * Sex, data = Joelle_data, alpha.along = "HI")
glm.hybrid(Trichuris ~ HI * All, data = Joelle_data, alpha.along = "HI")
source('~/Desktop/git_projects/Parasite_Load/R/ML_functions.R')
glm.hybrid(Trichuris ~ HI * Sex, data = Joelle_data, alpha.along = "HI")
glm.hybrid(Trichuris ~ HI * All, data = Joelle_data, alpha.along = "HI")
source('~/Desktop/git_projects/Parasite_Load/R/ML_functions.R')
glm.hybrid(Trichuris ~ HI * All, data = Joelle_data, alpha.along = "HI")
source('~/Desktop/git_projects/Parasite_Load/R/ML_functions.R')
source('~/Desktop/git_projects/Parasite_Load/R/ML_functions.R')
glm.hybrid(Trichuris ~ HI * Sex, data = Joelle_data, alpha.along = "HI")
source('~/Desktop/git_projects/Parasite_Load/R/ML_functions.R')
glm.hybrid(Trichuris ~ HI * All, data = Joelle_data, alpha.along = "HI")
source('~/Desktop/git_projects/Parasite_Load/R/ML_functions.R')
glm.hybrid(Trichuris ~ HI * All, data = Joelle_data, alpha.along = "HI")
