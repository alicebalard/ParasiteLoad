df$expected_freq = dnbinom(df$values, size = fit$estimate[1],
mu = fit$estimate[2]) * sum(df$observed_freq)
Chi2 = chisq.test(x = df$observed_freq, y = df$expected_freq)
# Plot the histogram & fitted distribution
#  hist(x, freq = F)
fitD = dnbinom(0:length(x), size = fit$estimate[1], mu = fit$estimate[2])
#  lines(fitD, lwd="3", col="red")
return(list(pos = pos, n = n, mean_intensity = mean_intensity,
prev = prev, CI_low = CI_low, CI_up = CI_up, fit.neg.bin = fit,
Chi2 = Chi2))
}
fit_neg_bin(Joelle_data$Aspiculuris.Syphacia)
fit_neg_bin <- function(x) {
x = as.vector(na.omit(x))
pos = sum(table(x)[names(table(x)) != 0])
n = sum(table(x))
mean_intensity = mean(na.omit(x))
prev = round(pos/n * 100,2)
CI_low = binom.exact(pos, n, p = pos/n,
alternative = c("two.sided", "less", "greater"),
tsmethod = c("minlike"),
conf.level = 0.95)$conf.int[1]*100
CI_up = binom.exact(pos, n, p = pos/n,
alternative = c("two.sided", "less", "greater"),
tsmethod = c("minlike"),
conf.level = 0.95)$conf.int[2]*100
fit = MASS::fitdistr(x, densfun = "negative binomial")
# Goodness of fit with the chi squared test
df = as.data.frame(table(x))
names(df) = c("values", "observed_freq")
df$values = as.numeric(as.character(df$values))
df$expected_freq = dnbinom(df$values, size = fit$estimate[1],
mu = fit$estimate[2]) * sum(df$observed_freq)
Chi2 = chisq.test(x = df$observed_freq, y = df$expected_freq)
# Plot the histogram & fitted distribution
hist(x)
fitD = dnbinom(0:length(x), size = fit$estimate[1], mu = fit$estimate[2])
#  lines(fitD, lwd="3", col="red")
return(list(pos = pos, n = n, mean_intensity = mean_intensity,
prev = prev, CI_low = CI_low, CI_up = CI_up, fit.neg.bin = fit,
Chi2 = Chi2))
}
fit_neg_bin(Joelle_data$Aspiculuris.Syphacia)
graphics.off()
par("mar")
par(mar=c(1,1,1,1))
fit_neg_bin <- function(x) {
x = as.vector(na.omit(x))
pos = sum(table(x)[names(table(x)) != 0])
n = sum(table(x))
mean_intensity = mean(na.omit(x))
prev = round(pos/n * 100,2)
CI_low = binom.exact(pos, n, p = pos/n,
alternative = c("two.sided", "less", "greater"),
tsmethod = c("minlike"),
conf.level = 0.95)$conf.int[1]*100
CI_up = binom.exact(pos, n, p = pos/n,
alternative = c("two.sided", "less", "greater"),
tsmethod = c("minlike"),
conf.level = 0.95)$conf.int[2]*100
fit = MASS::fitdistr(x, densfun = "negative binomial")
# Goodness of fit with the chi squared test
df = as.data.frame(table(x))
names(df) = c("values", "observed_freq")
df$values = as.numeric(as.character(df$values))
df$expected_freq = dnbinom(df$values, size = fit$estimate[1],
mu = fit$estimate[2]) * sum(df$observed_freq)
Chi2 = chisq.test(x = df$observed_freq, y = df$expected_freq)
# Plot the histogram & fitted distribution
hist(x)
fitD = dnbinom(0:length(x), size = fit$estimate[1], mu = fit$estimate[2])
#  lines(fitD, lwd="3", col="red")
return(list(pos = pos, n = n, mean_intensity = mean_intensity,
prev = prev, CI_low = CI_low, CI_up = CI_up, fit.neg.bin = fit,
Chi2 = Chi2))
}
fit_neg_bin(Joelle_data$Aspiculuris.Syphacia)
hist(x, breaks = 50, freq = T)
fitD = dnbinom(0:length(x), size = fit$estimate[1], mu = fit$estimate[2])
fit_neg_bin <- function(x) {
x = as.vector(na.omit(x))
pos = sum(table(x)[names(table(x)) != 0])
n = sum(table(x))
mean_intensity = mean(na.omit(x))
prev = round(pos/n * 100,2)
CI_low = binom.exact(pos, n, p = pos/n,
alternative = c("two.sided", "less", "greater"),
tsmethod = c("minlike"),
conf.level = 0.95)$conf.int[1]*100
CI_up = binom.exact(pos, n, p = pos/n,
alternative = c("two.sided", "less", "greater"),
tsmethod = c("minlike"),
conf.level = 0.95)$conf.int[2]*100
fit = MASS::fitdistr(x, densfun = "negative binomial")
# Goodness of fit with the chi squared test
df = as.data.frame(table(x))
names(df) = c("values", "observed_freq")
df$values = as.numeric(as.character(df$values))
df$expected_freq = dnbinom(df$values, size = fit$estimate[1],
mu = fit$estimate[2]) * sum(df$observed_freq)
Chi2 = chisq.test(x = df$observed_freq, y = df$expected_freq)
# Plot the histogram & fitted distribution
hist(x, breaks = 50, freq = T)
fitD = dnbinom(0:length(x), size = fit$estimate[1], mu = fit$estimate[2])
#  lines(fitD, lwd="3", col="red")
return(list(pos = pos, n = n, mean_intensity = mean_intensity,
prev = prev, CI_low = CI_low, CI_up = CI_up, fit.neg.bin = fit,
Chi2 = Chi2))
}
fit_neg_bin(Joelle_data$Aspiculuris.Syphacia)
fit_neg_bin(Joelle_data$Aspiculuris.Syphacia)
lines(fitD, lwd="3", col="red")
fit_neg_bin <- function(x) {
x = as.vector(na.omit(x))
pos = sum(table(x)[names(table(x)) != 0])
n = sum(table(x))
mean_intensity = mean(na.omit(x))
prev = round(pos/n * 100,2)
CI_low = binom.exact(pos, n, p = pos/n,
alternative = c("two.sided", "less", "greater"),
tsmethod = c("minlike"),
conf.level = 0.95)$conf.int[1]*100
CI_up = binom.exact(pos, n, p = pos/n,
alternative = c("two.sided", "less", "greater"),
tsmethod = c("minlike"),
conf.level = 0.95)$conf.int[2]*100
fit = MASS::fitdistr(x, densfun = "negative binomial")
# Goodness of fit with the chi squared test
df = as.data.frame(table(x))
names(df) = c("values", "observed_freq")
df$values = as.numeric(as.character(df$values))
df$expected_freq = dnbinom(df$values, size = fit$estimate[1],
mu = fit$estimate[2]) * sum(df$observed_freq)
Chi2 = chisq.test(x = df$observed_freq, y = df$expected_freq)
# Plot the histogram & fitted distribution
hist(x, breaks = 50, freq = T)
fitD = dnbinom(0:length(x), size = fit$estimate[1], mu = fit$estimate[2])
lines(fitD, lwd="3", col="red")
return(list(pos = pos, n = n, mean_intensity = mean_intensity,
prev = prev, CI_low = CI_low, CI_up = CI_up, fit.neg.bin = fit,
Chi2 = Chi2))
}
fit_neg_bin(Joelle_data$Aspiculuris.Syphacia)
fit_neg_bin <- function(x) {
x = as.vector(na.omit(x))
pos = sum(table(x)[names(table(x)) != 0])
n = sum(table(x))
mean_intensity = mean(na.omit(x))
prev = round(pos/n * 100,2)
CI_low = binom.exact(pos, n, p = pos/n,
alternative = c("two.sided", "less", "greater"),
tsmethod = c("minlike"),
conf.level = 0.95)$conf.int[1]*100
CI_up = binom.exact(pos, n, p = pos/n,
alternative = c("two.sided", "less", "greater"),
tsmethod = c("minlike"),
conf.level = 0.95)$conf.int[2]*100
fit = MASS::fitdistr(x, densfun = "negative binomial")
# Goodness of fit with the chi squared test
df = as.data.frame(table(x))
names(df) = c("values", "observed_freq")
df$values = as.numeric(as.character(df$values))
df$expected_freq = dnbinom(df$values, size = fit$estimate[1],
mu = fit$estimate[2]) * sum(df$observed_freq)
Chi2 = chisq.test(x = df$observed_freq, y = df$expected_freq)
# Plot the histogram & fitted distribution
hist(x, breaks = 50, freq = F)
fitD = dnbinom(0:length(x), size = fit$estimate[1], mu = fit$estimate[2])
lines(fitD, lwd="3", col="red")
return(list(pos = pos, n = n, mean_intensity = mean_intensity,
prev = prev, CI_low = CI_low, CI_up = CI_up, fit.neg.bin = fit,
Chi2 = Chi2))
}
fit_neg_bin(Joelle_data$Aspiculuris.Syphacia)
fit_neg_bin(Joelle_data$Trichuris)
fit_neg_bin(Joelle_data$Taenia)
fit_neg_bin(Joelle_data$Mastophorus)
MeanLoad <- function(intercept, growth, alpha, HI){
(intercept + growth*HI)*(1 - alpha*2*HI*(1 - HI))
}
MeanLoad <- function(intercept, growth, alpha, HI){
(intercept + growth*HI)*(1 - alpha*2*HI*(1 - HI))
}
MeanLoad(73.95,(73.95 - 33.49), 1.39, 0.5)
59.72 - MeanLoad(73.95,(73.95 - 33.49), 1.39, 0.5)
Joelle_data <- read.csv("../../../EvolutionFinalData.csv")
Joelle_data <- read.csv("../../EvolutionFinalData.csv")
library(exactci)
library(MASS)
graphics.off()
par("mar")
par(mar=c(1,1,1,1))
devtools::check()
devtools::check()
devtools::check()
devtool::install_github("alicebalard/Parasite_Load")
library(devtools)
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
G1 <- glm.hybrid::glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
simpara <- c(k = 2, alpha = 1.92,
"male:old.inter" = 14,
"male:young.inter" = 12,
"male:baby.inter" = 10,
"female:old.inter" = 20,
"female:young.inter" = 18,
"female:baby.inter" = 11,
"male:old.growth" = 2,
"male:young.growth" = 1,
"male:baby.growth" = -4,
"female:old.growth" = 2,
"female:young.growth" = 0,
"female:baby.growth" = -1)
SimulatedData <- function(param, n){
gdata <- data.frame(group1 = rep(c("male", "female"), each=n/2),
group2 = sample(c("old", "young", "baby"),
n, replace=TRUE))
gdata$HI<- round(runif(n), 2)
xloads <- by(gdata, gdata$group1:gdata$group2, function (x) {
pattern <- paste0("^", unique(x$group1), ":", unique(x$group2))
this.param <- param[grepl(pattern, names(param))]
loads <- rnbinom(n = nrow(x), size = param["k"],
mu = glm.hybrid:::MeanLoad(intercept=this.param[grepl("\\.inter",
names(this.param))],
growth=this.param[grepl("\\.growth",
names(this.param))],
alpha=param["alpha"],
HI=x$HI))
cbind(x, loads)
})
as.data.frame(do.call("rbind", xloads))
}
set.seed(5)
simdata <- SimulatedData(simpara, 1000)
G1 <- glm.hybrid::glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
G1
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
G1 <- glm.hybrid::glm.hybrid(loads ~ HI * group1, data = simdata, alpha.along = "HI", alpha.start = 1)
## Plot results for one group
HI = seq(0,1,0.001)
df <- data.frame(HI = HI,
ML = MeanLoad(G1$opt.param["female.inter"], G1$opt.param["female.growth"],
G1$opt.param["alpha"], HI))
library(ggplot2)
ggplot2::ggplot(df, aes(x = HI, y = ML)) +
geom_point() +
theme_classic()
devtools::check()
devtools::check()
devtools::check()
breakFormula <- function(formula){
## create the formula in the environment of our function
formula <- formula(substitute(formula))
response <- all.vars(formula)[1]
}
breakFormula(loads ~ HI*group1*group2)
list(formula, response)
breakFormula <- function(formula){
## create the formula in the environment of our function
formula <- formula(substitute(formula))
response <- all.vars(formula)[1]
list(formula, response)
}
breakFormula(loads ~ HI*group1*group2)
breakFormula <- function(formula){
## create the formula in the environment of our function
formula <- formula(substitute(formula))
response <- all.vars(formula)[1]
formula
}
breakFormula(loads ~ HI*group1*group2)
response <- all.vars(formula)[1]
formula
response
breakFormula <- function(formula){
## create the formula in the environment of our function
formula <- formula(substitute(formula))
response <- all.vars(formula)[1]
response
}
breakFormula(loads ~ HI*group1*group2)
list(response = response)
breakFormula <- function(formula){
## create the formula in the environment of our function
formula <- formula(substitute(formula))
response <- all.vars(formula)[1]
list(response = response)
}
breakFormula(loads ~ HI*group1*group2)
glm.hybrid <- function(formula, data,
alpha.along,
alpha.start = 0.1,
start.mod = MASS::glm.nb,
start.values = NA){
formula <- breakFormula(formula)
if(!class(start.mod)%in%"function"){
stop("supply a function to estimate starting parameters, even if you supply parameters verbatim (via start.values) use this for structure")
}
nb <- start.mod(formula, data=data)
nb.e  <- effects::allEffects(nb, xlevels=2)
if(length(nb.e) > 1){
stop("glm.hybrid not only currently only implements models with all potential interactions defined")
} else {
nb.e <- nb.e[[1]]
var <- nb.e[["variables"]]
is.factor.var <- sapply(var, function (x) x[["is.factor"]])
factor.var <- sort(names(is.factor.var[is.factor.var]))
alpha.var <- names(is.factor.var[!is.factor.var])
if (length(alpha.var) != 1 ||
!all(alpha.var %in% alpha.along) ||
max(data[, alpha.var]) > 1 ||
min(data[, alpha.var]) < 0){
stop("glm.hybrid is currently only implemented for one continuous variable scaled between 0 and 1, along which a non-linar effect (of intensity alpha) is tested")
} else {
original.inverse <- nb.e$transformation$inverse
nb.t <- as.data.frame(nb.e, transform = original.inverse)
start.param <- nb.t[, "fit"]
## if > 1 group, then nb.t[ , factor.var] is a data.frame
if (length(factor.var) == 1){
names(start.param) <- nb.t[, factor.var]
} else {
names(start.param) <- apply(nb.t[, factor.var], 1, paste, collapse=":")
}
names(start.param) <- paste0(names(start.param),
rep(c(".inter", ".growth"),
times=length(start.param)/2))
## we could reduce this by simply using ever even number parameter as intercept uneven as growth
## same in the ML loglik function
start.param[grepl("growth$", names(start.param))] <-
start.param[grepl("growth$", names(start.param))] -
start.param[grepl("inter$", names(start.param))]
param <- c(k=nb$theta, alpha=alpha.start, start.param)
param[names(start.values)] <- start.values
opt <- hybrid.maxim(param = param, data = data,
group.name = factor.var,
response = response,
alpha.along = alpha.along)
## add proxy of 95%CI
# bounds <- ML_bounds_Wald(param = param, data = data,
#                         group.name = factor.var,
#                        response = response,
#                       alpha.along = alpha.along)
out <- list(twologlik = opt$value*2,
start.mod = substitute(start.mod),
start.param = param[names(opt$par)],
override.start.values = start.values[names(opt$par)],
opt.param = opt$par,
#           opt.lower = bounds[,"LowerBounds"],
#           opt.upper = bounds[,"UpperBounds"],
df.residual = nb$df.residual-1,
converged = as.logical(opt$convergence))
class(out) <- append(class(out),"hybrid.glm")
return(out)
}
}
}
response
source('~/Schreibtisch/Git_projects/Parasite_Load/R/UserInput.R')
simpara <- c(k = 2, alpha = 1.92,
"male:old.inter" = 14,
"male:young.inter" = 12,
"male:baby.inter" = 10,
"female:old.inter" = 20,
"female:young.inter" = 18,
"female:baby.inter" = 11,
"male:old.growth" = 2,
"male:young.growth" = 1,
"male:baby.growth" = -4,
"female:old.growth" = 2,
"female:young.growth" = 0,
"female:baby.growth" = -1)
################## input end ##################
SimulatedData <- function(param, n){
gdata <- data.frame(group1 = rep(c("male", "female"), each=n/2),
group2 = sample(c("old", "young", "baby"),
n, replace=TRUE))
gdata$HI<- round(runif(n), 2)
xloads <- by(gdata, gdata$group1:gdata$group2, function (x) {
pattern <- paste0("^", unique(x$group1), ":", unique(x$group2))
this.param <- param[grepl(pattern, names(param))]
loads <- rnbinom(n = nrow(x), size = param["k"],
mu = glm.hybrid:::MeanLoad(intercept=this.param[grepl("\\.inter",
names(this.param))],
growth=this.param[grepl("\\.growth",
names(this.param))],
alpha=param["alpha"],
HI=x$HI))
cbind(x, loads)
})
as.data.frame(do.call("rbind", xloads))
}
set.seed(5)
simdata <- SimulatedData(simpara, 1000)
##################
.
.
simpara <- c(k = 2, alpha = 1.92,
"male:old.inter" = 14,
"male:young.inter" = 12,
"male:baby.inter" = 10,
"female:old.inter" = 20,
"female:young.inter" = 18,
"female:baby.inter" = 11,
"male:old.growth" = 2,
"male:young.growth" = 1,
"male:baby.growth" = -4,
"female:old.growth" = 2,
"female:young.growth" = 0,
"female:baby.growth" = -1)
SimulatedData <- function(param, n){
gdata <- data.frame(group1 = rep(c("male", "female"), each=n/2),
group2 = sample(c("old", "young", "baby"),
n, replace=TRUE))
gdata$HI<- round(runif(n), 2)
xloads <- by(gdata, gdata$group1:gdata$group2, function (x) {
pattern <- paste0("^", unique(x$group1), ":", unique(x$group2))
this.param <- param[grepl(pattern, names(param))]
loads <- rnbinom(n = nrow(x), size = param["k"],
mu = glm.hybrid:::MeanLoad(intercept=this.param[grepl("\\.inter",
names(this.param))],
growth=this.param[grepl("\\.growth",
names(this.param))],
alpha=param["alpha"],
HI=x$HI))
cbind(x, loads)
})
as.data.frame(do.call("rbind", xloads))
}
devtools::install_github("alicebalard/Parasite_Load")
simpara <- c(k = 2, alpha = 1.92,
"male:old.inter" = 14,
"male:young.inter" = 12,
"male:baby.inter" = 10,
"female:old.inter" = 20,
"female:young.inter" = 18,
"female:baby.inter" = 11,
"male:old.growth" = 2,
"male:young.growth" = 1,
"male:baby.growth" = -4,
"female:old.growth" = 2,
"female:young.growth" = 0,
"female:baby.growth" = -1)
install.packages("devtools")
install.packages("devtools")
R.Version()
install.packages("devtools")
R.Version()
install.packages("devtools")
install.packages("devtool")
install.packages("devtool")
install.packages("devtools")
packageStatus()
install.packages("devtools")
install.packages("devtools")
install.packages("~/Downloads/devtools_1.13.4.tar.gz", repos = NULL, type = "source")
install.packages("devtools")
install.packages("~/Downloads/memoise_1.1.0.tar.gz", repos = NULL, type = "source")
install.packages("~/Downloads/httr_1.3.1.tar.gz", repos = NULL, type = "source")
simpara <- c(k = 2, alpha = 1.92,
"male:old.inter" = 14,
"male:young.inter" = 12,
"male:baby.inter" = 10,
"female:old.inter" = 20,
"female:young.inter" = 18,
"female:baby.inter" = 11,
"male:old.growth" = 2,
"male:young.growth" = 1,
"male:baby.growth" = -4,
"female:old.growth" = 2,
"female:young.growth" = 0,
"female:baby.growth" = -1)
SimulatedData <- function(param, n){
gdata <- data.frame(group1 = rep(c("male", "female"), each=n/2),
group2 = sample(c("old", "young", "baby"),
n, replace=TRUE))
gdata$HI<- round(runif(n), 2)
xloads <- by(gdata, gdata$group1:gdata$group2, function (x) {
pattern <- paste0("^", unique(x$group1), ":", unique(x$group2))
this.param <- param[grepl(pattern, names(param))]
loads <- rnbinom(n = nrow(x), size = param["k"],
mu = :MeanLoad(intercept=this.param[grepl("\\.inter",
names(this.param))],
growth=this.param[grepl("\\.growth",
names(this.param))],
alpha=param["alpha"],
HI=x$HI))
cbind(x, loads)
})
as.data.frame(do.call("rbind", xloads))
}
source('~/Schreibtisch/Git_projects/Parasite_Load/tests/Simulate_and_test.R')
source('~/Schreibtisch/Git_projects/Parasite_Load/R/ML_functions.R')
source('~/Schreibtisch/Git_projects/Parasite_Load/R/UserInput.R')
source('~/Schreibtisch/Git_projects/Parasite_Load/tests/Simulate_and_test.R')
install.packages("~/Downloads/effects_4.0-0.tar.gz", repos = NULL, type = "source")
install.packages("~/Downloads/lme4_1.1-15.tar.gz", repos = NULL, type = "source")
options(BioC_mirror="http://master.bioconductor.org")
options(CRAN="http://origin.cran.rstudio.com")
install.packages("devtools")
options(CRAN="http://origin.cran.rstudio.com")
install.packages("devtools")
install.packages("devtools")
